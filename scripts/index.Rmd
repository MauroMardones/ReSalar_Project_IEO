---
title: "Derive Life story Parameters and natural mortality rates for Ostrea edulis to Minor Sea, Murcia, Spain"
subtitle: "Project ReSalar"
author: "Mardones, M; Delgado, M; etc"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: param.bib
csl: apa.csl
link-citations: yes
linkcolor: blue
output:
  html_document:
    keep_md: true
    toc: true
    toc_deep: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
    theme: cosmo
    fontsize: 0.9em
    linestretch: 1.7
    html-math-method: katex
    self-contained: true
    code-tools: true
editor_options: 
  markdown: 
    wrap: 72
---


```{r setup1}
rm(list = ls())
set.seed(9)
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = 'center',
                      fig.width = 7,
                      fig.height = 5,
                      dev = 'jpeg',
                      dpi = 300)
#XQuartz is a mess, put this in your onload to default to cairo instead
options(bitmapType = "cairo") 
# (https://github.com/tidyverse/ggplot2/issues/2655)
# Lo mapas se hacen mas rapido
```

## Load packages


```{r lib, message=F, echo= TRUE}
library(here)
library(kableExtra)
library(ggthemes)
library(ggrepel)
library(ggridges)
#analisis
library(ggpubr)
library(easystats) # multiples unciones analiticas
library(sf)
library(tidyverse, quietly = TRUE)
library(modelsummary)
library(terra) # replace raster
library(TropFishR)
library(mixR)
library(readxl)
```


# Methodology


## Data

Load DB from experiment in salar in Minor Sea. This data is monthly recollected.

```{r data}
# Restore the object
db <- read_excel(here("DATA",
                     "BD_lfd_crec_salinas.xlsx"),
                     sheet="TropFish")
```

## Separate `Date` column

```{r}
# Asigno  columnas a fechas separadas.
db1<- db %>%
  mutate(
    DIA = day(Date),
    MES = month(Date),
    ANO = year(Date))

table(db1$ANO)
```
histogram length data to viz in anthor way.



```{r lengcom, warning=FALSE}
jzstrata <- ggplot(db1,
             aes(x=size))+
  geom_histogram(binwidth = 3)+
  facet_wrap(~Sampling.point,
             ncol=5) +
  theme_bw()+
  xlab("Length (mm)")+
  ylab("Frecuency")
jzstrata
```

Statistical difference with 

```{r}
m <- aov(sizeE ~ Sampling.point, data=db1)
plot(TukeyHSD(m))
# Convertir la variable categórica a factor
db1$Sampling.point <- as.factor(db1$Sampling.point)
# Ajustar el modelo ANOVA
m <- aov(size ~ Sampling.point, data = db1)
# Aplicar TukeyHSD
tukey_result <- TukeyHSD(m)
```


```{r fig.height=6, fig.width=4}
par(mar = c(5, 8, 4, 2)) 
# Graficar el resultado
plot(tukey_result, cex.axis = 0.7)

```
Horizontal Lines (Confidence Intervals):

Each line represents the confidence interval for the difference in means between two groups. The wider the interval, the more uncertain the estimate is. If a confidence interval crosses zero (i.e., it includes zero), it means that the difference between the two group means is not statistically significant.

Midpoints of the Lines:

The midpoints of the horizontal lines represent the estimated difference in means between the two groups being compared.

Significance:
Lines entirely above or below zero indicate that there is a statistically significant difference between the two group means, since zero is not included in the confidence interval. Lines that cross zero indicate that there is no significant difference between the two group means.

Groups Compared:

On the y-axis, you'll see the pairs of groups being compared, typically written in the form "Group1-Group2." Each pair corresponds to one of the confidence intervals on the plot.

How to Interpret the Plot:
If a horizontal line does not overlap zero, the difference between the corresponding groups is significant at the given confidence level (typically 95%). If a horizontal line does overlap zero, there is no significant difference between those two groups.
The longer the horizontal line, the more variability or uncertainty there is in the estimated difference.


## Data Viz

Vizualization of length structure by month and Sampling point.


```{r lengcom}
data1 <- ggplot(db1,
             aes(x=size,
                 y=as.factor(MES),
                 fill=Sampling.point))+
  facet_grid(~ANO)+
  geom_density_ridges(stat = "binline", bins = 40, 
                      scale = 1.9, 
                      draw_baseline = T,
                      alpha=0.9)+  
  scale_fill_viridis_d(name="Sampling Point",
                       option="G")+
  theme_few()+
  xlab("Length (cm.)")+
  ylab("")+
  coord_flip()
data1
```

Now, must filter the DF

### Modal Progression analysis with `ELEFAN` to estimated `Linf`and `K`

Method based on @Pauly1987 and @Mildenberger2017

first we use `mixR` to identified numbers of component (modal compositions). With this result, set `ELEFAN` method




```{r eval=FALSE}

# Saco los NA
filtered_db <- db1 %>% 
    drop_na(size)

# select number of components

s_normalgs = select(filtered_db$size, ncomp = 2:8)
plot(s_normalgs)
```


```{r}
# fit a Normal mixture model
# Definir el número de componentes
ncomp <- 3

# Definir medias entre 20 y 70 cm (por ejemplo, espaciadas uniformemente)
medias <- seq(30, 70, length.out = ncomp)

# Definir pesos iniciales (uniformes)
pesos <- rep(1/ncomp, ncomp)  
# Definir desviaciones estándar iniciales (puedes ajustarlas según tus datos)
desviaciones <- rep(1, ncomp) 
# Ajustar el modelo de mezcla
modgs <- mixfit(filtered_db$size, 
                ncomp = ncomp, 
                pi = pesos, 
                mu = medias, 
                sd = desviaciones)

# Verificar el resultado
summary(modgs)

# Graficar el ajuste
plot(modgs,
     smoothness = 300,
     theme = "bw",
     trans=0.4)

```


Calculating the proportion of records per year and per stratum in a table. This table allows us to establish criteria for defining the strata on which we will analyze krill parameter. We leave out just `JOIN`.


```{r}
# Calcular la proporción
proporcion <- (round(table(sf5$ID) / sum(table(sf5$ID))*100,2))

# Crear una tabla con las proporciones
tabla_proporcion <- as.data.frame(proporcion)
tabla_proporcion$Categoria <- rownames(tabla_proporcion)
rownames(tabla_proporcion) <- NULL

# Renombrar las columnas
colnames(tabla_proporcion) <- c("Strata", "%")

# Mostrar la tabla utilizando kbl()
kbl(tabla_proporcion, 
    caption = "Proportion length register by Strata")  |> 
  kable_classic(full_width = F, 
                html_font = "Cambria") |> 
  kable_styling(bootstrap_options = "striped", 
                latex_options = "striped")
```

## Parameters estimation `k` and `L_inf_`



```{r}

set.seed(1)
data <- data.frame(length.mm. = sample(c(rpois(300, lambda = 60),
           rpois(200, lambda = 100), rpois(100, lambda = 150)),
           size = 1000, replace = TRUE),
           dates = seq.Date(as.Date("2015-10-02"),as.Date("2016-08-28"),
           length.out = 1000))
# create lfq data
lfq_dat <- lfqCreate(data,Lname = "length.mm.", Dname = "dates", aggregate_dates = TRUE,
   length_unit = "mm", bin_size = 0.5, plot=TRUE, plus_group=c(TRUE,15.75))


db1$Date <- as.Date(db1$Date)
  # Crear un objeto lfq para el ID actual
lfq <- lfqCreate(data = db1,
                   Lname = "size",
                   Dname = "Date",
                   bin_size = 0.2,
                 length_unit = "mm",
                 Lmin = 0.8,
                 aggregate_dates=T)

# Graficar el objeto lfq
plot(lfq, Fname = "catch",
       main = "Ostrea edulis")

```

Identified difference in length distribution just to male:

```{r message=FALSE}
Bhattacharya(lfq)
```


now we assign objet to male `lfq_result` and female `lfq_resulthe` and plot with `lfqRestructure()`


## (Documentation) Restructuring of length frequency data

First step of the *Electronic LEngth Frequency ANalysis (ELEFAN)*, which is restructuring length-frequency data (lfq). This is done according to a certain protocol, described by many authors (see Details or References for more information).


```{r}
# Restructurar el objeto lfq
lfqbin <- lfqRestructure(lfq, 
                         MA = 5, 
                         addl.sqrt = F)
# Graficar el objeto lfq reestructurado
plot(lfqbin, hist.col = c("white", "black"),
     image.col = c(rep(rgb(1,0.8,0.8),1000), "white", 
                   rep(rgb(0.8,0.8,1),1000)),
       ylim = c(0,max(lfqbin$midLengths)))
  # Ajustar curvas al objeto lfq reestructurado
  tmp <- lfqFitCurves(lfqbin, par = list(Linf=7.9, 
                                          K=0.7,
                                          t_anchor=0.1),
                      draw = TRUE, col=4, lty=2)
```


```{r}
#### Parameters dif methods
res_simple <- ELEFAN(lfq,
                     Linf_fix = NA,
                     Linf_range = seq(6.0,8.0,0.1),
                     K_range = exp(seq(log(0.1), 
                                       log(2),
                                       length.out = 50)),
                     C = 0,
                     ts = 0,  
                     MA = 5,  
                     addl.sqrt = F,
                     agemax = 28,
                     flagging.out = TRUE,
                     method = "optimise",cross.date = NULL,
                     cross.midLength = NULL,
                     cross.max = FALSE,
                     hide.progressbar = FALSE,
                     plot = FALSE,contour = FALSE,
                     add.values = TRUE,
                     rsa.colors = terrain.colors(20),
                     plot_title = TRUE)

# run ELEFAN with simulated annealing
res_SA <- ELEFAN_SA(lfq,
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 28,
                    seasonalised = T, 
                    addl.sqrt = F,
                    init_par = list(Linf = 7.8, 
                                    K = 0.3, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 7.0,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 8.0,
                                  K = 0.9, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    plot = FALSE,
                    plot.score = TRUE)

# run ELEFAN with genetic algorithm
res_GA <- ELEFAN_GA(lfq, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 50, 
                    agemax = 28,
                    addl.sqrt = F,
                      low_par = list(Linf = 7.0,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 8.0,
                                  K = 0.9, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE,
                    plot = T)


```


Parámetros comunes:

`Linf_range`: Para hacer que ELEFAN sea comparable con los otros métodos, he ajustado `Linf_range` a seq(7.0, 8.0, 0.1) para que coincida con los límites de low_par y up_par en los otros métodos. `K_range`: Utilicé el mismo rango de K para los tres métodos, con valores entre 0.01 y 0.9. 

En los tres métodos, he activado la estacionalidad (`seasonalised = TRUE` en `ELEFAN_SA` y `ELEFAN_GA`) y utilicé valores de `C` = 0.5 y `ts` = 0.5 para asegurar la coherencia. Estos parametros dicen relaciñon con la oscilacion estacional fdel crecimiento, información que para *O. edulis* no tenemos y por eso la dejamos en la mitad del año.

Los límites inferiores (`low_par`) y superiores (`up_par`) son consistentes entre los tres métodos.
init_par en ELEFAN_SA:

Establecer los valores iniciales para `Linf`, `K`, `t_anchor`, `C` y `ts` en `ELEFAN_SA` para ser consistentes con los otros métodos.


```{r}
# Parâmetros comunes
Linf_range <- seq(6.0, 8.0, 0.1)
K_range <- exp(seq(log(0.01), log(0.9), length.out = 50)) # Coincide con los otros métodos

low_par <- list(Linf = 6.0, K = 0.01, t_anchor = 0, C = 0, ts = 0)
up_par <- list(Linf = 8.0, K = 0.9, t_anchor = 1, C = 1, ts = 1)
init_par <- list(Linf = 7.8, K = 0.3, t_anchor = 0.5, C = 0.5, ts = 0.5)

# Método 1: ELEFAN con optimización
res_simple <- ELEFAN(lfq,
                     Linf_fix = NA,
                     Linf_range = Linf_range, # Coincide con otros métodos
                     K_range = K_range, # Coincide con otros métodos
                     C = 0.5,  # Estacionalidad
                     ts = 0.5, # Valor inicial de ts
                     MA = 5,
                     addl.sqrt = FALSE,
                     agemax = 28,
                     flagging.out = TRUE,
                     method = "optimise",
                     cross.date = NULL,
                     cross.midLength = NULL,
                     cross.max = FALSE,
                     hide.progressbar = FALSE,
                     plot = FALSE,
                     contour = FALSE,
                     add.values = TRUE,
                     rsa.colors = terrain.colors(20),
                     plot_title = TRUE)

# Método 2: ELEFAN con Simulated Annealing (SA)
res_SA <- ELEFAN_SA(lfq,
                    SA_time = 60 * 0.5,
                    MA = 5,
                    agemax = 28,
                    seasonalised = TRUE,  # Estacionalidad activada
                    addl.sqrt = FALSE,
                    init_par = init_par, # Valores iniciales comunes
                    low_par = low_par,   # Limites inferiores comunes
                    up_par = up_par,     # Limites superiores comunes
                    plot = FALSE,
                    plot.score = TRUE)

# Método 3: ELEFAN con algoritmo genético (GA)
res_GA <- ELEFAN_GA(lfq,
                    MA = 5,
                    seasonalised = TRUE,  # Estacionalidad activada
                    maxiter = 50,
                    agemax = 28,
                    addl.sqrt = FALSE,
                    low_par = low_par,  # Limites inferiores comunes
                    up_par = up_par,    # Limites superiores comunes
                    monitor = FALSE,
                    plot = TRUE)

```

Resuming parameters to both sex  by strata to krill
```{r}
#male
GAbs <- unlist(res_GAbs$par)
SAbs <- unlist(res_SAbs$par)
GAei <- unlist(res_GAei$par)
SAei <- unlist(res_SAei$par)
GAsswi <- unlist(res_GAsswi$par)
SAsswi <- unlist(res_SAsswi$par)
GAgs <- unlist(res_GAgs$par)
SAgs <- unlist(res_SAgs$par)
#female
GAbshe <- unlist(res_GAbshe$par)
SAbshe <- unlist(res_SAbshe$par)
GAeihe <- unlist(res_GAeihe$par)
SAeihe <- unlist(res_SAeihe$par)
GAsswihe <- unlist(res_GAsswihe$par)
SAsswihe <- unlist(res_SAsswihe$par)
GAgshe <- unlist(res_GAgshe$par)
SAgshe <- unlist(res_SAgshe$par)
# join 
t_k_linf_m <- rbind(GAbs[1:2],
                  SAbs[1:2],
                  GAei[1:2],
                  SAei[1:2],
                  GAsswi[1:2],
                  SAsswi[1:2],
                  GAgs[1:2],
                  SAgs[1:2])
t_k_linf_f <- rbind(GAbshe[1:2],
                  SAbshe[1:2],
                  GAeihe[1:2],
                  SAeihe[1:2],
                  GAsswihe[1:2],
                  SAsswihe[1:2],
                  GAgshe[1:2],
                  SAgshe[1:2])
row_names <- c("GA BS", "SA BS", "GA EI", 
                 "SA EI", "GA SSIW", "SA SSIW",
                 "GA GS", "SA GS")
rownames(t_k_linf_m) <- row_names
rownames(t_k_linf_f) <- row_names
col_names_m <- c("L inf Male", "K Male")
col_names_f <- c("L inf Female", "K Female")
colnames(t_k_linf_m) <- col_names_m
colnames(t_k_linf_f) <- col_names_f


total_para <- round(cbind(t_k_linf_f,
                    t_k_linf_m),3)
t_k_linf_total <- as_tibble(total_para, rownames = "group")


means <- t_k_linf_total %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
  mutate(group = "Mean")

t_k_linf <- bind_rows(t_k_linf_total, means)
```

```{r eval=FALSE}
write_csv(t_k_linf, "parametros_krill.csv")
```

total Table with `L_inf_` and `K`

```{r}
t_k_linf %>%
  separate(group, into = c("METHOD", "STRATA"), sep = " ") %>% 
  kbl(booktabs = T,
      position="ht!",
    caption = "Parametres LH in different strata with 2 algoritms to estimation") %>%
  kable_styling(latex_options = c("striped",
                                  "condensed"),
                full_width = FALSE)

```

Made VB curves by methot and strata by male

separated group


```{r}
t_k_linf_sep <- t_k_linf %>% 
  filter(group != "Mean") %>% 
   separate(group, into = c("METHOD", "STRATA"), sep = " ")
```


```{r}
# Definir la función de Von Bertalanffy
von_bertalanffy <- function(t, L_inf, K) {
  L_inf * (1 - exp(-K * (t-t0)))
}

# Generar una secuencia de tiempos (por ejemplo, de 0 a 5 años)
t0 <- -0.3
time <- seq(0, 7, by = 0.1)

# Calcular longitud esperada para cada zona y tiempo
df_curves_male <- t_k_linf_sep %>%
  dplyr::select(c(1:2, 5:6)) %>% 
  rowwise() %>%
  mutate(length = list(von_bertalanffy(time, `L inf Male`, `K Male`))) %>%
  unnest(length)
# Agregar el vector de tiempo al DataFrame df_curves
df_curves_male$time <- rep(time, nrow(t_k_linf_sep))
# Graficar con ggplot
male <- ggplot(df_curves_male,
               aes(x = time, 
                              y = length,
                              group=STRATA,
                              colour=STRATA)) +
  geom_line(linewidth=1.1) +
  labs(title = "Male",
       x = "years",
       y = "Length (cm)") +
  theme_few()+
  facet_wrap(.~METHOD)+
  scale_colour_viridis_d(option="F",
                         name="Strata")

```
Made VB curves by methot and strata by female

```{r}
# Calcular longitud esperada para cada zona y tiempo
df_curves_female <- t_k_linf_sep %>%
  dplyr::select(c(1:4)) %>% 
  rowwise() %>%
  mutate(length = list(von_bertalanffy(time, `L inf Female`, `K Female`))) %>%
  unnest(length)
# Agregar el vector de tiempo al DataFrame df_curves
df_curves_female$time <- rep(time, nrow(t_k_linf_sep))
# Graficar con ggplot
female <- ggplot(df_curves_female,
               aes(x = time, 
                              y = length,
                              group=STRATA,
                              colour=STRATA)) +
  geom_line(linewidth=1.1) +
  labs(title = "Female",
       x = "years",
       y = "Length (cm)") +
  theme_few()+
  facet_wrap(.~METHOD)+
  scale_colour_viridis_d(option="F",
                         name="Strata")

```

both plot

```{r fig.width=10, fig.height=8}
ggarrange(female, male, common.legend = TRUE,
          ncol=1,
          legend="bottom")
```


### Method Nonlinear Mixed-Effects Models

Fit a nonlinear mixed-effects model (NLMM) to data, via maximum likelihood using `lme4` (@Bates2015) to calcularte parametrs

(work in progress)

```{r eval=FALSE, echo=TRUE}

#We use firts a descomposition methot with library `mixR` and the

sf52020 <- sf5 %>% 
  filter(sex_code %in% "F",
         ID == "EI",
         Year =="2020") %>% 
  drop_na(length_total_cm)

# fit a Normal mixture model
mod1 = mixfit(sf52020$length_total_cm, ncomp = 4,
              pi = c(0.5, 0.5, 0.5, 0.5), 
              mu = c( 3, 4, 5, 6), 
              sd = c(0.2, 0.2, 0.2, 0.2))
mod2_weibull = mixfit(sf6$length_total_cm, family = 'weibull', ncomp = 3)

s_weibull = select(sf5a$length_total_cm, ncomp = 2:6, family = 'weibull')

s_normal = select(sf5a$length_total_cm, ncomp = 2:6)
plot(s_weibull)
plot(s_normal)

# plot the fitted model# plot the fitted model# plot the fitted model
plot(mod1)
plot(mod2_weibull)

# fit a Normal mixture model (equal variance)
mod1_ev = mixfit(sf6$length_total_cm, ncomp = 2, ev = TRUE)

```

## Natural Mortality in Krill

In this exercises different bioanalogic methods are tested with General Algoritm

#### MALE

```{r}
MSSWI <- c(res_GAsswi$par, list(agemax = res_GAsswi$agemax))
# use the function M_empirical to estimate natural mortality
Msswi <- M_empirical(Linf = MSSWI$Linf, K_l = MSSWI$K, 
                  tmax = MSSWI$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                            "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Bransfield
BS <- c(res_GAbs$par, list(agemax = res_GAbs$agemax))

# use the function M_empirical to estimate natural mortality
Mbs <- M_empirical(Linf = BS$Linf, K_l = BS$K, 
                  tmax = BS$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                              "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# GERLACHE
GS <- c(res_GAgs$par, list(agemax = res_GAgs$agemax))

# use the function M_empirical to estimate natural mortality
Mgs <- M_empirical(Linf = GS$Linf, K_l = GS$K, 
                  tmax = GS$agemax, temp = 5,
                   tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Elephand Island
MEI <- c(res_GAei$par, list(agemax = res_GAei$agemax))

# use the function M_empirical to estimate natural mortality
Mei <- M_empirical(Linf = MEI$Linf, K_l = MEI$K, 
                  tmax = MEI$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
```

#### FEMALE

```{r}
MSSWIhe <- c(res_GAsswihe$par, list(agemax = res_GAsswihe$agemax))
# use the function M_empirical to estimate natural mortality
Msswihe <- M_empirical(Linf = MSSWIhe$Linf, K_l = MSSWIhe$K, 
                  tmax = MSSWIhe$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", 
                            "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Bransfield
BShe <- c(res_GAbshe$par, list(agemax = res_GAbshe$agemax))

# use the function M_empirical to estimate natural mortality
Mbshe <- M_empirical(Linf = BShe$Linf, K_l = BShe$K, 
                  tmax = BShe$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", 
                              "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# GERLACHE
GShe <- c(res_GAgshe$par, list(agemax = res_GAgshe$agemax))

# use the function M_empirical to estimate natural mortality
Mgshe <- M_empirical(Linf = GShe$Linf, K_l = GShe$K, 
                  tmax = GShe$agemax, temp = 5,
                   tm50 = 2,
                  method = c("Pauly_Linf", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Elephand Island
MEIhe <- c(res_GAeihe$par, list(agemax = res_GAeihe$agemax))

# use the function M_empirical to estimate natural mortality
Meihe <- M_empirical(Linf = MEIhe$Linf, K_l = MEIhe$K, 
                  tmax = MEIhe$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
```

```{r}
# junto las bases

Total_M_male <- cbind(Mei, Mbs, Mgs, Msswi)
colnames(Total_M_male) <- c("EI", "BS" , "GS", "SSIW")
mean_m <- colMeans(Total_M_male, na.rm = TRUE)
Total_M_Mean_male <- rbind(Total_M_male, Mean = mean_m)
# Agregar los promedios como una nueva fila al final del array

Total_M_femal <- cbind(Meihe, Mbshe, Mgshe, Msswihe)
colnames(Total_M_femal) <- c("EI", "BS" , "GS", "SSIW")
mean_m <- colMeans(Total_M_femal, na.rm = TRUE)
Total_M_Mean_femal <- rbind(Total_M_femal, Mean = mean_m)
```


```{r}
Total_M_Mean_male  %>%
  kbl(booktabs = T,
      position="ht!",
    caption = "Estimated M by Strata for Male") %>%
  kable_styling(latex_options = c("striped",
                                  "condensed"),
                full_width = FALSE)

Total_M_Mean_femal  %>%
  kbl(booktabs = T,
      position="ht!",
    caption = "Estimated M by Strata for Female") %>%
  kable_styling(latex_options = c("striped",
                                  "condensed"),
                full_width = FALSE)

```


Plot to female
```{r}
# Convertir la matriz a data.frame
df_female <- as.data.frame(Total_M_Mean_femal)

# Agregar la columna de métodos
df_female$Method <- rownames(Total_M_Mean_femal)

# Convertir el data.frame a formato largo
df_long <- df_female %>%
  pivot_longer(cols = EI:SSIW, 
               names_to = "Stratum", 
               values_to = "Value")

# Dot Plot
m_female<- ggplot(df_long %>%
                              drop_na() %>%
                              filter(Method != "Mean"), 
                            aes(x = Stratum, 
                                y = Value,
                                fill = Method)) +
 geom_point(size = 3,     
             shape = 21,   
             color = "black") +
  geom_text_repel(aes(label = round(Value, 3)),  
                  size = 3,                      
                  box.padding = 0.5,  
                  point.padding = 1.5,
                  segment.color = 'grey50',
                  min.segment.length = 0.5, 
                  nudge_y = 0.2,
                  direction = "both") +
  labs(title = "Female",
       x = "",
       y = "Natural Mortality",
       fill = "Method") +
  theme_few() +
  scale_fill_viridis_d(option = "H") +
  ylim(0, 2)
```

Plot to male
```{r}
# Convertir la matriz a data.frame
df_male <- as.data.frame(Total_M_Mean_male)

# Agregar la columna de métodos
df_male$Method <- rownames(Total_M_Mean_male)

# Convertir el data.frame a formato largo
df_long_male <- df_male %>%
  pivot_longer(cols = EI:SSIW, 
               names_to = "Stratum", 
               values_to = "Value") 

# Dot Plot
m_male<- ggplot(df_long_male %>%
                              drop_na() %>%
                              filter(Method != "Mean"), 
                            aes(x = Stratum, 
                                y = Value,
                                fill = Method)) +
  geom_point(size = 3,     
             shape = 21,   
             color = "black") +
  geom_text_repel(aes(label = round(Value, 3)),  
                  size = 3,                      
                  box.padding = 0.5,  
                  point.padding = 1.5,
                  segment.color = 'grey50',
                  min.segment.length = 0.5, 
                  nudge_y = 0.2,
                  direction = "both") +
  labs(title = "Male",
       x = "",
       y = "Natural Mortality",
       fill = "Method") +
  theme_few() +
  scale_fill_viridis_d(option = "H") +
  ylim(0, 2)

```

both plot

```{r}
ggarrange(m_female, m_male, 
          common.legend = TRUE,
          ncol=1,
          legend="right")
```
Statistical diferences in female

```{r}
# Realizar la prueba ANOVA
anova_result <- aov(Value ~ Stratum, data = df_long_male %>% drop_na())
summary(anova_result)
# Realizar la prueba post hoc de Tukey
tukey_result <- TukeyHSD(anova_result)
# Convertir los resultados de Tukey a un data frame
tukey_df <- as.data.frame(tukey_result$Stratum)
tukey_df$pair <- rownames(tukey_df)
tukey_df <- tukey_df %>%
  mutate(Stratum1 = sapply(strsplit(pair, "-"), `[`, 1),
         Stratum2 = sapply(strsplit(pair, "-"), `[`, 2))

# Seleccionar las columnas relevantes
tukey_table <- tukey_df %>%
  dplyr::select(Stratum1, Stratum2, diff, `p adj`, `lwr`, `upr`) %>%
  rename(Difference = diff, 
         P_value = `p adj`, 
         Lower_CI = `lwr`, 
         Upper_CI = `upr`)


kbl(tukey_table, 
    caption = "Test to differences between strata")  |> 
  kable_classic(full_width = F, 
                html_font = "Cambria") |> 
  kable_styling(bootstrap_options = "striped", 
                latex_options = "striped")



```
Statistical diferences in female

```{r}
# Realizar la prueba ANOVA
anova_result_ma <- aov(Value ~ Stratum, data = df_long %>% drop_na())
summary(anova_result_ma)
# Realizar la prueba post hoc de Tukey
tukey_result_ma <- TukeyHSD(anova_result_ma)
# Convertir los resultados de Tukey a un data frame
tukey_df_ma <- as.data.frame(tukey_result_ma$Stratum)
tukey_df_ma$pair <- rownames(tukey_df_ma)
tukey_df_ma <- tukey_df_ma %>%
  mutate(Stratum1 = sapply(strsplit(pair, "-"), `[`, 1),
         Stratum2 = sapply(strsplit(pair, "-"), `[`, 2))

# Seleccionar las columnas relevantes
tukey_table_ma <- tukey_df_ma %>%
  dplyr::select(Stratum1, Stratum2, diff, `p adj`, `lwr`, `upr`) %>%
  rename(Difference = diff, 
         P_value = `p adj`, 
         Lower_CI = `lwr`, 
         Upper_CI = `upr`)


kbl(tukey_table, 
    caption = "Test to differences between strata")  |> 
  kable_classic(full_width = F, 
                html_font = "Cambria") |> 
  kable_styling(bootstrap_options = "striped", 
                latex_options = "striped")


```


# References


